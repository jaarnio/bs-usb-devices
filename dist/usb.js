(()=>{var e={516:(e,t,r)=>{const i=require;"function"==typeof i.addon?e.exports=i.addon.bind(i):e.exports=r(524)},524:(e,t,r)=>{var i=r(358),s=r(17),n=r(37),o=require,c=process.config&&process.config.variables||{},a=!!process.env.PREBUILDS_ONLY,l=process.versions.modules,d=process.versions&&process.versions.electron||process.env.ELECTRON_RUN_AS_NODE||"undefined"!=typeof window&&window.process&&"renderer"===window.process.type?"electron":process.versions&&process.versions.nw?"node-webkit":"node",f=process.env.npm_config_arch||n.arch(),u=process.env.npm_config_platform||n.platform(),h=process.env.LIBC||(function(e){return"linux"===e&&i.existsSync("/etc/alpine-release")}(u)?"musl":"glibc"),p=process.env.ARM_VERSION||("arm64"===f?"8":c.arm_version)||"",v=(process.versions.uv||"").split(".")[0];function b(e){return o(b.resolve(e))}function g(e){try{return i.readdirSync(e)}catch(e){return[]}}function _(e,t){var r=g(e).filter(t);return r[0]&&s.join(e,r[0])}function m(e){return/\.node$/.test(e)}function w(e){var t=e.split("-");if(2===t.length){var r=t[0],i=t[1].split("+");if(r&&i.length&&i.every(Boolean))return{name:e,platform:r,architectures:i}}}function E(e,t){return function(r){return null!=r&&r.platform===e&&r.architectures.includes(t)}}function I(e,t){return e.architectures.length-t.architectures.length}function D(e){var t=e.split("."),r={file:e,specificity:0};if("node"===t.pop()){for(var i=0;i<t.length;i++){var s=t[i];if("node"===s||"electron"===s||"node-webkit"===s)r.runtime=s;else if("napi"===s)r.napi=!0;else if("abi"===s.slice(0,3))r.abi=s.slice(3);else if("uv"===s.slice(0,2))r.uv=s.slice(2);else if("armv"===s.slice(0,4))r.armv=s.slice(4);else{if("glibc"!==s&&"musl"!==s)continue;r.libc=s}r.specificity++}return r}}function y(e,t){return function(r){return!(null==r||r.runtime&&r.runtime!==e&&!function(e){return"node"===e.runtime&&e.napi}(r)||r.abi&&r.abi!==t&&!r.napi||r.uv&&r.uv!==v||r.armv&&r.armv!==p||r.libc&&r.libc!==h)}}function T(e){return function(t,r){return t.runtime!==r.runtime?t.runtime===e?-1:1:t.abi!==r.abi?t.abi?-1:1:t.specificity!==r.specificity?t.specificity>r.specificity?-1:1:0}}e.exports=b,b.resolve=b.path=function(e){e=s.resolve(e||".");try{var t=o(s.join(e,"package.json")).name.toUpperCase().replace(/-/g,"_");process.env[t+"_PREBUILD"]&&(e=process.env[t+"_PREBUILD"])}catch(e){}if(!a){var r=_(s.join(e,"build/Release"),m);if(r)return r;var i=_(s.join(e,"build/Debug"),m);if(i)return i}var n=S(e);if(n)return n;var c=S(s.dirname(process.execPath));if(c)return c;var b=["platform="+u,"arch="+f,"runtime="+d,"abi="+l,"uv="+v,p?"armv="+p:"","libc="+h,"node="+process.versions.node,process.versions.electron?"electron="+process.versions.electron:"","webpack=true"].filter(Boolean).join(" ");throw new Error("No native build was found for "+b+"\n    loaded from: "+e+"\n");function S(e){var t=g(s.join(e,"prebuilds")).map(w).filter(E(u,f)).sort(I)[0];if(t){var r=s.join(e,"prebuilds",t.name),i=g(r).map(D).filter(y(d,l)).sort(T(d))[0];return i?s.join(r,i.file):void 0}}},b.parseTags=D,b.matchTags=y,b.compareTags=T,b.parseTuple=w,b.matchTuple=E,b.compareTuples=I},747:function(e,t,r){"use strict";var i=this&&this.__createBinding||(Object.create?function(e,t,r,i){void 0===i&&(i=r);var s=Object.getOwnPropertyDescriptor(t,r);s&&!("get"in s?!t.__esModule:s.writable||s.configurable)||(s={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,i,s)}:function(e,t,r,i){void 0===i&&(i=r),e[i]=t[r]}),s=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||i(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.LibUSBException=t.useUsbDkBackend=t.getDeviceList=t.Transfer=t.Device=t.webusb=t.findBySerialNumber=t.findByIds=t.usb=void 0;const n=r(837),o=r(289),c=r(826);t.usb=c,t.findByIds=(e,t)=>c.getDeviceList().find((r=>r.deviceDescriptor.idVendor===e&&r.deviceDescriptor.idProduct===t)),t.findBySerialNumber=async e=>{const t=c.getDeviceList(),r=e=>!!e.interfaces;for(const i of t)try{r(i)||i.open();const t=(0,n.promisify)(i.getStringDescriptor).bind(i),s=await t(i.deviceDescriptor.iSerialNumber);if(s&&s.toString()===e)return i}catch{}finally{try{r(i)&&i.close()}catch{}}};const a=new o.WebUSB;t.webusb=a;var l=r(826);Object.defineProperty(t,"Device",{enumerable:!0,get:function(){return l.Device}}),Object.defineProperty(t,"Transfer",{enumerable:!0,get:function(){return l.Transfer}}),Object.defineProperty(t,"getDeviceList",{enumerable:!0,get:function(){return l.getDeviceList}}),Object.defineProperty(t,"useUsbDkBackend",{enumerable:!0,get:function(){return l.useUsbDkBackend}}),Object.defineProperty(t,"LibUSBException",{enumerable:!0,get:function(){return l.LibUSBException}}),s(r(926),t),s(r(338),t),s(r(911),t),s(r(333),t),s(r(289),t),s(r(946),t)},387:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const i=r(17),s=r(516)((0,i.join)(__dirname,"..",".."));e.exports=s},926:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Capability=void 0,t.Capability=class{constructor(e,t){if(this.device=e,this.id=t,!e._bosDescriptor)throw new Error("bosDescriptor not found");this.descriptor=e._bosDescriptor.capabilities[this.id],this.type=this.descriptor.bDevCapabilityType,this.data=this.descriptor.dev_capability_data}}},338:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},147:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ExtendedDevice=void 0;const i=r(387),s=r(333),n=r(926),o=e=>!!e&&e instanceof Uint8Array;t.ExtendedDevice=class{constructor(){this._timeout=1e3}get timeout(){return this._timeout||1e3}set timeout(e){this._timeout=e}get configDescriptor(){try{return this.__getConfigDescriptor()}catch(e){if(e.errno===i.LIBUSB_ERROR_NOT_FOUND)return;throw e}}get allConfigDescriptors(){try{return this.__getAllConfigDescriptors()}catch(e){if(e.errno===i.LIBUSB_ERROR_NOT_FOUND)return[];throw e}}get parent(){return this.__getParent()}open(e=!0){if(this.__open(),this.interfaces=[],!1===e)return;const t=this.configDescriptor?this.configDescriptor.interfaces.length:0;for(let e=0;e<t;e++)this.interfaces[e]=new s.Interface(this,e)}close(){this.__close(),this.interfaces=void 0}setConfiguration(e,t){this.__setConfiguration(e,(e=>{if(!e){this.interfaces=[];const e=this.configDescriptor?this.configDescriptor.interfaces.length:0;for(let t=0;t<e;t++)this.interfaces[t]=new s.Interface(this,t)}t&&t.call(this,e)}))}controlTransfer(e,t,r,s,n,c){const a=!!(e&i.LIBUSB_ENDPOINT_IN),l=a?n:n.length;if(a){if(l<0)throw new TypeError("Expected size number for IN transfer (based on bmRequestType)")}else if(!o(n))throw new TypeError("Expected buffer for OUT transfer (based on bmRequestType)");const d=Buffer.alloc(l+i.LIBUSB_CONTROL_SETUP_SIZE);d.writeUInt8(e,0),d.writeUInt8(t,1),d.writeUInt16LE(r,2),d.writeUInt16LE(s,4),d.writeUInt16LE(l,6),a||d.set(n,i.LIBUSB_CONTROL_SETUP_SIZE);const f=new i.Transfer(this,0,i.LIBUSB_TRANSFER_TYPE_CONTROL,this.timeout,((e,t,r)=>{c&&(a?c.call(this,e,t.slice(i.LIBUSB_CONTROL_SETUP_SIZE,i.LIBUSB_CONTROL_SETUP_SIZE+r)):c.call(this,e,r))}));try{f.submit(d)}catch(e){c&&process.nextTick((()=>c.call(this,e,void 0)))}return this}interface(e){if(!this.interfaces)throw new Error("Device must be open before searching for interfaces");e=e||0;for(let t=0;t<this.interfaces.length;t++)if(this.interfaces[t].interfaceNumber===e)return this.interfaces[t];throw new Error(`Interface not found for address: ${e}`)}getStringDescriptor(e,t){0!==e?this.controlTransfer(i.LIBUSB_ENDPOINT_IN,i.LIBUSB_REQUEST_GET_DESCRIPTOR,i.LIBUSB_DT_STRING<<8|e,1033,255,((e,r)=>{if(e)return t(e);t(void 0,o(r)?r.toString("utf16le",2):void 0)})):t()}getBosDescriptor(e){return this._bosDescriptor?e(void 0,this._bosDescriptor):this.deviceDescriptor.bcdUSB<513?e(void 0,void 0):void this.controlTransfer(i.LIBUSB_ENDPOINT_IN,i.LIBUSB_REQUEST_GET_DESCRIPTOR,i.LIBUSB_DT_BOS<<8,0,i.LIBUSB_DT_BOS_SIZE,((t,r)=>{if(t)return t.errno===i.LIBUSB_TRANSFER_STALL?e(void 0,void 0):e(t,void 0);if(!o(r))return e(void 0,void 0);const s=r.readUInt16LE(2);this.controlTransfer(i.LIBUSB_ENDPOINT_IN,i.LIBUSB_REQUEST_GET_DESCRIPTOR,i.LIBUSB_DT_BOS<<8,0,s,((t,r)=>{if(t)return t.errno===i.LIBUSB_TRANSFER_STALL?e(void 0,void 0):e(t,void 0);if(!o(r))return e(void 0,void 0);const s={bLength:r.readUInt8(0),bDescriptorType:r.readUInt8(1),wTotalLength:r.readUInt16LE(2),bNumDeviceCaps:r.readUInt8(4),capabilities:[]};let n=i.LIBUSB_DT_BOS_SIZE;for(;n<s.wTotalLength;){const e={bLength:r.readUInt8(n+0),bDescriptorType:r.readUInt8(n+1),bDevCapabilityType:r.readUInt8(n+2),dev_capability_data:r.slice(n+3,n+r.readUInt8(n+0))};s.capabilities.push(e),n+=e.bLength}this._bosDescriptor=s,e(void 0,this._bosDescriptor)}))}))}getCapabilities(e){const t=[];this.getBosDescriptor(((r,i)=>{if(r)return e(r,void 0);const s=i?i.capabilities.length:0;for(let e=0;e<s;e++)t.push(new n.Capability(this,e));e(void 0,t)}))}}},911:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OutEndpoint=t.InEndpoint=t.Endpoint=void 0;const i=r(361),s=r(387),n=r(837);class o extends i.EventEmitter{constructor(e,t){super(),this.device=e,this.timeout=0,this.descriptor=t,this.address=t.bEndpointAddress,this.transferType=3&t.bmAttributes}clearHalt(e){return this.device.__clearHalt(this.address,e)}makeTransfer(e,t){return new s.Transfer(this.device,this.address,this.transferType,e,t)}}t.Endpoint=o,t.InEndpoint=class extends o{constructor(e,t){super(e,t),this.direction="in",this.pollTransfers=[],this.pollTransferSize=0,this.pollPending=0,this.pollActive=!1,this.transferAsync=(0,n.promisify)(this.transfer).bind(this)}transfer(e,t){const r=Buffer.alloc(e),i=(e,i,s)=>{t.call(this,e,r.slice(0,s))};try{this.makeTransfer(this.timeout,i).submit(r)}catch(e){process.nextTick((()=>t.call(this,e)))}return this}startPoll(e,t,r){const i=(e,t,i,o)=>{if(e?e.errno!==s.LIBUSB_TRANSFER_CANCELLED&&this.pollActive&&(this.emit("error",e),this.stopPoll()):this.emit("data",i.slice(0,o)),this.pollActive)n(t);else if(this.pollPending--,0===this.pollPending&&(this.pollTransfers=[],this.pollActive=!1,this.emit("end"),r)){const t=(null==e?void 0:e.errno)===s.LIBUSB_TRANSFER_CANCELLED;r(t?void 0:e,i,o,t)}},n=e=>{try{e.submit(Buffer.alloc(this.pollTransferSize),((t,r,s)=>{i(t,e,r,s)}))}catch(e){this.emit("error",e),this.stopPoll()}};return this.pollTransfers=this.startPollTransfers(e,t,(function(e,t,r){i(e,this,t,r)})),this.pollTransfers.forEach(n),this.pollPending=this.pollTransfers.length,this.pollTransfers}startPollTransfers(e=3,t=this.descriptor.wMaxPacketSize,r){if(this.pollActive)throw new Error("Polling already active");this.pollTransferSize=t,this.pollActive=!0,this.pollPending=0;const i=[];for(let t=0;t<e;t++){const e=this.makeTransfer(0,r);i[t]=e}return i}stopPoll(e){if(!this.pollActive)throw new Error("Polling is not active.");for(let e=0;e<this.pollTransfers.length;e++)try{this.pollTransfers[e].cancel()}catch(e){this.emit("error",e)}this.pollActive=!1,e&&this.once("end",e)}},t.OutEndpoint=class extends o{constructor(e,t){super(e,t),this.direction="out",this.transferAsync=(0,n.promisify)(this.transfer).bind(this)}transfer(e,t){var r;e?(r=e)&&r instanceof Uint8Array||(e=Buffer.from(e)):e=Buffer.alloc(0);const i=(e,r,i)=>{t&&t.call(this,e,i||0)};try{this.makeTransfer(this.timeout,i).submit(e)}catch(e){process.nextTick((()=>i(e)))}return this}transferWithZLP(e,t){e.length%this.descriptor.wMaxPacketSize==0?(this.transfer(e),this.transfer(Buffer.alloc(0),t)):this.transfer(e,t)}}},826:(e,t,r)=>{"use strict";const i=r(361),s=r(147),n=r(387);n.INIT_ERROR&&console.warn("Failed to initialize libusb."),Object.setPrototypeOf(n,i.EventEmitter.prototype),Object.defineProperty(n,"pollHotplug",{value:!1,writable:!0}),Object.defineProperty(n,"pollHotplugDelay",{value:500,writable:!0}),n.Device&&Object.getOwnPropertyNames(s.ExtendedDevice.prototype).forEach((e=>{Object.defineProperty(n.Device.prototype,e,Object.getOwnPropertyDescriptor(s.ExtendedDevice.prototype,e)||Object.create(null))}));let o=new Set;const c=()=>{const e=new Set(n.getDeviceList());for(const t of e)o.has(t)||n.emit("attach",t);for(const t of o)e.has(t)||n.emit("detach",t);o=e};let a=!1;const l=(e=!1)=>{if(e)a=!0;else{if(!a)return;c()}setTimeout((()=>l()),n.pollHotplugDelay)},d=()=>setTimeout((()=>c()),n.pollHotplugDelay);let f=0;n.on("newListener",(e=>{"attach"!==e&&"detach"!==e||0===n.listenerCount("attach")+n.listenerCount("detach")&&(f=n.pollHotplug?0:n._supportedHotplugEvents(),1!==f&&(o=new Set(n.getDeviceList())),f?(n._enableHotplugEvents(),2===f&&(n.on("attachIds",d),n.on("detachIds",d))):l(!0))})),n.on("removeListener",(e=>{"attach"!==e&&"detach"!==e||0===n.listenerCount("attach")+n.listenerCount("detach")&&(f?(n._disableHotplugEvents(),2===f&&(n.off("attachIds",d),n.off("detachIds",d))):a=!1)})),e.exports=n},333:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Interface=void 0;const i=r(387),s=r(911),n=r(837);t.Interface=class{constructor(e,t){this.device=e,this.id=t,this.altSetting=0,this.refresh(),this.releaseAsync=(0,n.promisify)(this.release).bind(this),this.setAltSettingAsync=(0,n.promisify)(this.setAltSetting).bind(this)}refresh(){if(!this.device.configDescriptor)return;this.descriptor=this.device.configDescriptor.interfaces[this.id][this.altSetting],this.interfaceNumber=this.descriptor.bInterfaceNumber,this.endpoints=[];const e=this.descriptor.endpoints.length;for(let t=0;t<e;t++){const e=this.descriptor.endpoints[t],r=e.bEndpointAddress&i.LIBUSB_ENDPOINT_IN?s.InEndpoint:s.OutEndpoint;this.endpoints[t]=new r(this.device,e)}}claim(){this.device.__claimInterface(this.id)}release(e,t){let r=!1;"boolean"==typeof e?r=e:t=e;const i=()=>{this.device.__releaseInterface(this.id,(e=>{e||(this.altSetting=0,this.refresh()),t&&t.call(this,e)}))};if(r&&0!==this.endpoints.length){let e=this.endpoints.length;this.endpoints.forEach((t=>{"in"===t.direction&&t.pollActive?(t.once("end",(()=>{0==--e&&i()})),t.stopPoll()):0==--e&&i()}))}else i()}isKernelDriverActive(){return this.device.__isKernelDriverActive(this.id)}detachKernelDriver(){return this.device.__detachKernelDriver(this.id)}attachKernelDriver(){return this.device.__attachKernelDriver(this.id)}setAltSetting(e,t){this.device.__setInterface(this.id,e,(r=>{r||(this.altSetting=e,this.refresh()),t&&t.call(this,r)}))}endpoint(e){return this.endpoints.find((t=>t.address===e))}}},289:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebUSB=t.getWebUsb=void 0;const i=r(826),s=r(361),n=r(946);t.getWebUsb=()=>navigator&&navigator.usb?navigator.usb:new c;class o extends Error{constructor(e,t){super(e),this.name=t}}class c{constructor(e={}){this.options=e,this.emitter=new s.EventEmitter,this.knownDevices=new Map,this.authorisedDevices=new Set;const t=async e=>{const t=await this.getWebDevice(e);if(t&&this.isAuthorisedDevice(t)){const e={type:"connect",device:t};this.emitter.emit("connect",e)}},r=async e=>{if(this.knownDevices.has(e)){const t=this.knownDevices.get(e);if(t&&this.isAuthorisedDevice(t)){const e={type:"disconnect",device:t};this.emitter.emit("disconnect",e)}}};this.emitter.on("newListener",(e=>{0===this.emitter.listenerCount(e)&&("connect"===e?i.addListener("attach",t):"disconnect"===e&&i.addListener("detach",r))})),this.emitter.on("removeListener",(e=>{0===this.emitter.listenerCount(e)&&("connect"===e?i.removeListener("attach",t):"disconnect"===e&&i.removeListener("detach",r))}))}set onconnect(e){this._onconnect&&(this.removeEventListener("connect",this._onconnect),this._onconnect=void 0),e&&(this._onconnect=e,this.addEventListener("connect",this._onconnect))}set ondisconnect(e){this._ondisconnect&&(this.removeEventListener("disconnect",this._ondisconnect),this._ondisconnect=void 0),e&&(this._ondisconnect=e,this.addEventListener("disconnect",this._ondisconnect))}addEventListener(e,t){this.emitter.addListener(e,t)}removeEventListener(e,t){this.emitter.removeListener(e,t)}dispatchEvent(e){return!1}async requestDevice(e){if(!e)throw new TypeError("requestDevice error: 1 argument required, but only 0 present");if(e.constructor!=={}.constructor)throw new TypeError("requestDevice error: parameter 1 (options) is not an object");if(!e.filters)throw new TypeError("requestDevice error: required member filters is undefined");if(e.filters.constructor!==[].constructor)throw new TypeError("requestDevice error: the provided value cannot be converted to a sequence");e.filters.forEach((e=>{if(e.protocolCode&&!e.subclassCode)throw new TypeError("requestDevice error: subclass code is required");if(e.subclassCode&&!e.classCode)throw new TypeError("requestDevice error: class code is required")}));let t=await this.loadDevices(e.filters);if(t=t.filter((t=>this.filterDevice(t,e.filters))),0===t.length)throw new o("Failed to execute 'requestDevice' on 'USB': No device selected.","NotFoundError");try{const e=this.options.devicesFound?await this.options.devicesFound(t):t[0];if(!e)throw new o("Failed to execute 'requestDevice' on 'USB': No device selected.","NotFoundError");return this.authorisedDevices.add({vendorId:e.vendorId,productId:e.productId,classCode:e.deviceClass,subclassCode:e.deviceSubclass,protocolCode:e.deviceProtocol,serialNumber:e.serialNumber}),e}catch(e){throw new o("Failed to execute 'requestDevice' on 'USB': No device selected.","NotFoundError")}}async getDevices(){const e=this.options.allowAllDevices?void 0:this.options.allowedDevices;return(await this.loadDevices(e)).filter((e=>this.isAuthorisedDevice(e)))}async loadDevices(e){let t=i.getDeviceList();t=this.quickFilter(t,e);const r=new Map;for(const e of t){const t=await this.getWebDevice(e);t&&r.set(e,t)}return this.knownDevices=r,[...this.knownDevices.values()]}async getWebDevice(e){if(!this.knownDevices.has(e)){this.options.deviceTimeout&&(e.timeout=this.options.deviceTimeout);try{const t=await n.WebUSBDevice.createInstance(e);this.knownDevices.set(e,t)}catch{}}return this.knownDevices.get(e)}quickFilter(e,t){return t&&t.length?e.filter((e=>t.some((t=>!(t.vendorId&&t.vendorId!==e.deviceDescriptor.idVendor||t.productId&&t.productId!==e.deviceDescriptor.idProduct))))):e}filterDevice(e,t){return!t||!t.length||t.some((t=>{if(t.vendorId&&t.vendorId!==e.vendorId)return!1;if(t.productId&&t.productId!==e.productId)return!1;if(t.classCode){if(!e.configuration)return!1;if(e.configuration.interfaces.some((e=>!(t.classCode&&t.classCode!==e.alternate.interfaceClass||t.subclassCode&&t.subclassCode!==e.alternate.interfaceSubclass||t.protocolCode&&t.protocolCode!==e.alternate.interfaceProtocol))))return!0}return!(t.classCode&&t.classCode!==e.deviceClass||t.subclassCode&&t.subclassCode!==e.deviceSubclass||t.protocolCode&&t.protocolCode!==e.deviceProtocol||t.serialNumber&&t.serialNumber!==e.serialNumber)}))}isAuthorisedDevice(e){return!!this.options.allowAllDevices||!(!this.options.allowedDevices||!this.filterDevice(e,this.options.allowedDevices))||[...this.authorisedDevices.values()].some((t=>t.vendorId===e.vendorId&&t.productId===e.productId&&t.classCode===e.deviceClass&&t.subclassCode===e.deviceSubclass&&t.protocolCode===e.deviceProtocol&&t.serialNumber===e.serialNumber))}}t.WebUSB=c},946:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebUSBDevice=void 0;const i=r(826),s=r(837),n=r(37);class o{static async createInstance(e){const t=new o(e);return await t.initialize(),t}constructor(e){this.device=e,this.configurations=[];const t=this.decodeVersion(e.deviceDescriptor.bcdUSB);this.usbVersionMajor=t.major,this.usbVersionMinor=t.minor,this.usbVersionSubminor=t.sub,this.deviceClass=e.deviceDescriptor.bDeviceClass,this.deviceSubclass=e.deviceDescriptor.bDeviceSubClass,this.deviceProtocol=e.deviceDescriptor.bDeviceProtocol,this.vendorId=e.deviceDescriptor.idVendor,this.productId=e.deviceDescriptor.idProduct;const r=this.decodeVersion(e.deviceDescriptor.bcdDevice);this.deviceVersionMajor=r.major,this.deviceVersionMinor=r.minor,this.deviceVersionSubminor=r.sub,this.controlTransferAsync=(0,s.promisify)(this.device.controlTransfer).bind(this.device),this.setConfigurationAsync=(0,s.promisify)(this.device.setConfiguration).bind(this.device),this.resetAsync=(0,s.promisify)(this.device.reset).bind(this.device),this.getStringDescriptorAsync=(0,s.promisify)(this.device.getStringDescriptor).bind(this.device)}get configuration(){if(!this.device.configDescriptor)return;const e=this.device.configDescriptor.bConfigurationValue;return this.configurations.find((t=>t.configurationValue===e))}get opened(){return!!this.device.interfaces}async open(){try{if(this.opened)return;this.device.open()}catch(e){throw new Error(`open error: ${e}`)}}async close(){try{if(!this.opened)return;try{if(this.configuration)for(const e of this.configuration.interfaces)await this._releaseInterface(e.interfaceNumber),this.configuration.interfaces[this.configuration.interfaces.indexOf(e)]={interfaceNumber:e.interfaceNumber,alternate:e.alternate,alternates:e.alternates,claimed:!1}}catch(e){}this.device.close()}catch(e){throw new Error(`close error: ${e}`)}}async selectConfiguration(e){if(!this.opened||!this.device.configDescriptor)throw new Error("selectConfiguration error: invalid state");if(this.device.configDescriptor.bConfigurationValue!==e){if(!this.configurations.find((t=>t.configurationValue===e)))throw new Error("selectConfiguration error: configuration not found");try{await this.setConfigurationAsync(e)}catch(e){throw new Error(`selectConfiguration error: ${e}`)}}}async claimInterface(e){if(!this.opened)throw new Error("claimInterface error: invalid state");if(!this.configuration)throw new Error("claimInterface error: interface not found");const t=this.configuration.interfaces.find((t=>t.interfaceNumber===e));if(!t)throw new Error("claimInterface error: interface not found");if(!t.claimed)try{this.device.interface(e).claim(),this.configuration.interfaces[this.configuration.interfaces.indexOf(t)]={interfaceNumber:e,alternate:t.alternate,alternates:t.alternates,claimed:!0}}catch(e){throw new Error(`claimInterface error: ${e}`)}}async releaseInterface(e){if(await this._releaseInterface(e),this.configuration){const t=this.configuration.interfaces.find((t=>t.interfaceNumber===e));t&&(this.configuration.interfaces[this.configuration.interfaces.indexOf(t)]={interfaceNumber:e,alternate:t.alternate,alternates:t.alternates,claimed:!1})}}async selectAlternateInterface(e,t){if(!this.opened)throw new Error("selectAlternateInterface error: invalid state");if(!this.configuration)throw new Error("selectAlternateInterface error: interface not found");const r=this.configuration.interfaces.find((t=>t.interfaceNumber===e));if(!r)throw new Error("selectAlternateInterface error: interface not found");if(!r.claimed)throw new Error("selectAlternateInterface error: invalid state");try{const r=this.device.interface(e);await r.setAltSettingAsync(t)}catch(e){throw new Error(`selectAlternateInterface error: ${e}`)}}async controlTransferIn(e,t){try{this.checkDeviceOpen();const r=this.controlTransferParamsToType(e,i.LIBUSB_ENDPOINT_IN),s=await this.controlTransferAsync(r,e.request,e.value,e.index,t);return{data:s?new DataView(new Uint8Array(s).buffer):void 0,status:"ok"}}catch(e){if(e.errno===i.LIBUSB_TRANSFER_STALL)return{status:"stall"};if(e.errno===i.LIBUSB_TRANSFER_OVERFLOW)return{status:"babble"};throw new Error(`controlTransferIn error: ${e}`)}}async controlTransferOut(e,t){try{this.checkDeviceOpen();const r=this.controlTransferParamsToType(e,i.LIBUSB_ENDPOINT_OUT),s=t?Buffer.from(t):Buffer.alloc(0);return{bytesWritten:await this.controlTransferAsync(r,e.request,e.value,e.index,s),status:"ok"}}catch(e){if(e.errno===i.LIBUSB_TRANSFER_STALL)return{bytesWritten:0,status:"stall"};throw new Error(`controlTransferOut error: ${e}`)}}async clearHalt(e,t){try{const r=t|("in"===e?i.LIBUSB_ENDPOINT_IN:i.LIBUSB_ENDPOINT_OUT);await this.controlTransferAsync(i.LIBUSB_RECIPIENT_ENDPOINT,1,0,r,Buffer.from(new Uint8Array))}catch(e){throw new Error(`clearHalt error: ${e}`)}}async transferIn(e,t){try{this.checkDeviceOpen();const r=this.getEndpoint(e|i.LIBUSB_ENDPOINT_IN),s=await r.transferAsync(t);return{data:s?new DataView(new Uint8Array(s).buffer):void 0,status:"ok"}}catch(e){if(e.errno===i.LIBUSB_TRANSFER_STALL)return{status:"stall"};if(e.errno===i.LIBUSB_TRANSFER_OVERFLOW)return{status:"babble"};throw new Error(`transferIn error: ${e}`)}}async transferOut(e,t){try{this.checkDeviceOpen();const r=this.getEndpoint(e|i.LIBUSB_ENDPOINT_OUT),s=Buffer.from(t);return{bytesWritten:await r.transferAsync(s),status:"ok"}}catch(e){if(e.errno===i.LIBUSB_TRANSFER_STALL)return{bytesWritten:0,status:"stall"};throw new Error(`transferOut error: ${e}`)}}async reset(){try{await this.resetAsync()}catch(e){throw new Error(`reset error: ${e}`)}}async isochronousTransferIn(e,t){throw new Error("isochronousTransferIn error: method not implemented")}async isochronousTransferOut(e,t,r){throw new Error("isochronousTransferOut error: method not implemented")}async forget(){throw new Error("forget error: method not implemented")}async initialize(){try{this.opened||(this.device.open(),255===this.deviceClass&&"darwin"===(0,n.platform)()&&await this.setConfigurationAsync(1)),this.manufacturerName=await this.getStringDescriptor(this.device.deviceDescriptor.iManufacturer),this.productName=await this.getStringDescriptor(this.device.deviceDescriptor.iProduct),this.serialNumber=await this.getStringDescriptor(this.device.deviceDescriptor.iSerialNumber),this.configurations=await this.getConfigurations()}catch(e){throw new Error(`initialize error: ${e}`)}finally{this.opened&&this.device.close()}}decodeVersion(e){const t=`0000${e.toString(16)}`.slice(-4);return{major:parseInt(t.substr(0,2),void 0),minor:parseInt(t.substr(2,1),void 0),sub:parseInt(t.substr(3,1),void 0)}}async getStringDescriptor(e){try{const t=await this.getStringDescriptorAsync(e);return t?t.toString():""}catch(e){return""}}async getConfigurations(){const e=[];for(const t of this.device.allConfigDescriptors){const r=[];for(const e of t.interfaces){const t=[];for(const r of e){const e=[];for(const t of r.endpoints)e.push({endpointNumber:127&t.bEndpointAddress,direction:t.bEndpointAddress&i.LIBUSB_ENDPOINT_IN?"in":"out",type:(3&t.bmAttributes)===i.LIBUSB_TRANSFER_TYPE_BULK?"bulk":(3&t.bmAttributes)===i.LIBUSB_TRANSFER_TYPE_INTERRUPT?"interrupt":"isochronous",packetSize:t.wMaxPacketSize});t.push({alternateSetting:r.bAlternateSetting,interfaceClass:r.bInterfaceClass,interfaceSubclass:r.bInterfaceSubClass,interfaceProtocol:r.bInterfaceProtocol,interfaceName:await this.getStringDescriptor(r.iInterface),endpoints:e})}const s=e[0].bInterfaceNumber,n=t.find((e=>e.alternateSetting===this.device.interface(s).altSetting));n&&r.push({interfaceNumber:s,alternate:n,alternates:t,claimed:!1})}e.push({configurationValue:t.bConfigurationValue,configurationName:await this.getStringDescriptor(t.iConfiguration),interfaces:r})}return e}getEndpoint(e){if(this.device.interfaces)for(const t of this.device.interfaces){const r=t.endpoint(e);if(r)return r}}controlTransferParamsToType(e,t){return("device"===e.recipient?i.LIBUSB_RECIPIENT_DEVICE:"interface"===e.recipient?i.LIBUSB_RECIPIENT_INTERFACE:"endpoint"===e.recipient?i.LIBUSB_RECIPIENT_ENDPOINT:i.LIBUSB_RECIPIENT_OTHER)|("standard"===e.requestType?i.LIBUSB_REQUEST_TYPE_STANDARD:"class"===e.requestType?i.LIBUSB_REQUEST_TYPE_CLASS:i.LIBUSB_REQUEST_TYPE_VENDOR)|t}async _releaseInterface(e){if(!this.opened)throw new Error("releaseInterface error: invalid state");if(!this.configuration)throw new Error("releaseInterface error: interface not found");const t=this.configuration.interfaces.find((t=>t.interfaceNumber===e));if(!t)throw new Error("releaseInterface error: interface not found");if(t.claimed)try{const t=this.device.interface(e);await t.releaseAsync()}catch(e){throw new Error(`releaseInterface error: ${e}`)}}checkDeviceOpen(){if(!this.opened)throw new Error("The device must be opened first")}}t.WebUSBDevice=o},192:e=>{"use strict";e.exports=require("@brightsign/deviceinfo")},361:e=>{"use strict";e.exports=require("events")},358:e=>{"use strict";e.exports=require("fs")},37:e=>{"use strict";e.exports=require("os")},17:e=>{"use strict";e.exports=require("path")},837:e=>{"use strict";e.exports=require("util")}},t={};function r(i){var s=t[i];if(void 0!==s)return s.exports;var n=t[i]={exports:{}};return e[i].call(n.exports,n,n.exports,r),n.exports}(()=>{diClass=r(192);const e=new diClass,t=function(e){for(i in console.log("Parsing USB Topology: ",e),e){console.log("Device: "+e[i].raw+" "+e[i].category);let r=e[i];"HUB"===r.category&&t(r.children),"NET"===r.category&&console.log("Found "+r.fid+" interface "+r.ident)}};e.getUsbTopology().then((e=>{console.log("USB Topology:",e),t(e)})).catch((e=>{console.error("Error:",e)})),r(747).getDeviceList().forEach((e=>{console.log(`Device: ${e.deviceDescriptor.idVendor}:${e.deviceDescriptor.idProduct}`),console.log(`  Type: ${e.deviceDescriptor.iProduct}`),console.log(`  Bus: ${e.busNumber}`),console.log(`  Address: ${e.deviceAddress}`),console.log(`  Ports: ${e.portNumbers}`),console.log(`  Manufacturer: \n        ${e.deviceDescriptor.iManufacturer}`),console.log(`  Serial Number: \n        ${e.deviceDescriptor.iSerialNumber}`)}))})()})();